'use strict';

/**
 * Push notification module for Claude Remote.
 * Sends alerts via ntfy.sh when Claude needs input or finishes generation.
 */

const DEFAULT_TOPIC = null; // No default â€” must be provided or auto-generated by server
const DEFAULT_DEBOUNCE_MS = 3000;

class Notifier {
  /**
   * @param {object} options
   * @param {string} [options.topic] - ntfy.sh topic name
   * @param {number} [options.debounceMs] - debounce delay in milliseconds
   * @param {function} [options.fetchFn] - fetch implementation (for testing)
   * @param {function} [options.logger] - logging function
   */
  constructor(options = {}) {
    this.topic = options.topic || process.env.CLAUDE_REMOTE_NTFY_TOPIC || null;
    this.debounceMs = options.debounceMs || DEFAULT_DEBOUNCE_MS;
    this.fetchFn = options.fetchFn || globalThis.fetch;
    this.logger = options.logger || console.log;
    this.errorLogger = options.errorLogger || console.error;

    this._debounceTimer = null;
    this._lastNotifyTime = 0;
    this._enabled = !!this.topic; // Disable if no topic configured
  }

  /**
   * Get the full ntfy.sh URL for this topic.
   */
  get url() {
    return `https://ntfy.sh/${this.topic}`;
  }

  /**
   * Enable or disable notifications.
   */
  setEnabled(enabled) {
    this._enabled = enabled;
  }

  /**
   * Send a notification immediately (no debounce).
   * @param {string} title - notification title
   * @param {string} body - notification body text
   * @param {string} [priority] - ntfy priority (min, low, default, high, urgent)
   * @param {string} [tags] - comma-separated ntfy tags
   */
  async sendImmediate(title, body, priority = 'default', tags = 'robot') {
    if (!this._enabled) return { sent: false, reason: 'disabled' };

    try {
      const res = await this.fetchFn(this.url, {
        method: 'POST',
        headers: {
          'Title': title,
          'Priority': priority,
          'Tags': tags,
        },
        body: body,
      });

      if (!res.ok) {
        this.errorLogger(`Failed to send ntfy alert: ${res.statusText}`);
        return { sent: false, reason: res.statusText };
      }

      this.logger(`[ntfy] Alert sent to ${this.topic}`);
      this._lastNotifyTime = Date.now();
      return { sent: true };
    } catch (err) {
      this.errorLogger(`Error sending ntfy alert: ${err.message}`);
      return { sent: false, reason: err.message };
    }
  }

  /**
   * Schedule a debounced notification.
   * If more data arrives before the debounce period, the notification is canceled.
   * @param {string} title
   * @param {string} body
   */
  scheduleNotification(title, body) {
    if (!this._enabled) return;

    if (this._debounceTimer) {
      clearTimeout(this._debounceTimer);
    }

    this._debounceTimer = setTimeout(() => {
      this.sendImmediate(title, body);
      this._debounceTimer = null;
    }, this.debounceMs);
  }

  /**
   * Cancel any pending debounced notification.
   */
  cancelPending() {
    if (this._debounceTimer) {
      clearTimeout(this._debounceTimer);
      this._debounceTimer = null;
    }
  }

  /**
   * Check if a notification is pending.
   */
  isPending() {
    return this._debounceTimer !== null;
  }

  /**
   * Cleanup resources.
   */
  destroy() {
    this.cancelPending();
  }
}

module.exports = { Notifier, DEFAULT_TOPIC, DEFAULT_DEBOUNCE_MS };
