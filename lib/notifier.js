'use strict';

/**
 * Push notification module for Claude Remote.
 * Sends alerts via ntfy.sh when Claude needs input or finishes generation.
 */

const DEFAULT_TOPIC = null; // No default â€” must be provided or auto-generated by server
const DEFAULT_DEBOUNCE_MS = 3000;

class Notifier {
  /**
   * @param {object} options
   * @param {string} [options.topic] - ntfy.sh topic name
   * @param {object} [options.io] - Socket.IO server instance for browser notifications
   * @param {number} [options.debounceMs] - debounce delay in milliseconds
   * @param {function} [options.fetchFn] - fetch implementation (for testing)
   * @param {function} [options.logger] - logging function
   */
  constructor(options = {}) {
    this.topic = options.topic || process.env.CLAUDE_REMOTE_NTFY_TOPIC || null;
    this.io = options.io || null;
    this.debounceMs = options.debounceMs || DEFAULT_DEBOUNCE_MS;
    this.fetchFn = options.fetchFn || globalThis.fetch;
    this.logger = options.logger || console.log;
    this.errorLogger = options.errorLogger || console.error;

    this._debounceTimer = null;
    this._lastNotifyTime = 0;
    // Enabled if either ntfy topic or io is available
    this._enabled = !!(this.topic || this.io);
  }

  /**
   * Get the full ntfy.sh URL for this topic.
   */
  get url() {
    return `https://ntfy.sh/${this.topic}`;
  }

  /**
   * Enable or disable notifications.
   */
  setEnabled(enabled) {
    this._enabled = enabled;
  }

  /**
   * Send a notification immediately (no debounce).
   * @param {string} title - notification title
   * @param {string} body - notification body text
   * @param {string} [priority] - ntfy priority (min, low, default, high, urgent)
   * @param {string} [tags] - comma-separated ntfy tags
   */
  async sendImmediate(title, body, priority = 'default', tags = 'robot') {
    if (!this._enabled) return { sent: false, reason: 'disabled' };

    // Emit browser notification via Socket.IO (always, if io is available)
    if (this.io) {
      try {
        this.io.emit('notify', { title, body, priority, tags });
      } catch (err) {
        this.errorLogger(`Error emitting browser notification: ${err.message}`);
      }
    }

    // Send ntfy.sh push notification (only if topic is configured)
    if (this.topic) {
      try {
        const res = await this.fetchFn(this.url, {
          method: 'POST',
          headers: {
            'Title': title,
            'Priority': priority,
            'Tags': tags,
          },
          body: body,
        });

        if (!res.ok) {
          this.errorLogger(`Failed to send ntfy alert: ${res.statusText}`);
        } else {
          this.logger(`[ntfy] Alert sent to ${this.topic}`);
        }
      } catch (err) {
        this.errorLogger(`Error sending ntfy alert: ${err.message}`);
      }
    }

    this._lastNotifyTime = Date.now();
    return { sent: true };
  }

  /**
   * Schedule a debounced notification.
   * If more data arrives before the debounce period, the notification is canceled.
   * @param {string} title
   * @param {string} body
   */
  scheduleNotification(title, body) {
    if (!this._enabled) return;

    if (this._debounceTimer) {
      clearTimeout(this._debounceTimer);
    }

    this._debounceTimer = setTimeout(() => {
      this.sendImmediate(title, body);
      this._debounceTimer = null;
    }, this.debounceMs);
  }

  /**
   * Cancel any pending debounced notification.
   */
  cancelPending() {
    if (this._debounceTimer) {
      clearTimeout(this._debounceTimer);
      this._debounceTimer = null;
    }
  }

  /**
   * Check if a notification is pending.
   */
  isPending() {
    return this._debounceTimer !== null;
  }

  /**
   * Cleanup resources.
   */
  destroy() {
    this.cancelPending();
  }
}

module.exports = { Notifier, DEFAULT_TOPIC, DEFAULT_DEBOUNCE_MS };
